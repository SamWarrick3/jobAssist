"""_summary_

Returns:
    _type_: _description_
"""
# TODO logger is not printing to console, LOG variable doesn't seem to hold the logger?
# TODO check and make sure all functions work in ipython and for different job apps
# what all the possible types are and to try and find all possible input types that can be expected
# Generated by Selenium IDE
# rainbow csv query: SELECT * ORDER BY a4 DESC (a4 is score)
#self = autofill.TestAutofillApp()
#self.setup_method(self)
#self.open_tabs(url_list)
#self.driver.switch_to.window(self.driver.window_handles[0])
import pytest
import logging
import sys
import time
import json
import csv
from enum import Enum
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import Select
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

URL = ""
FIRST_NAME_FORMATS = ["First Name", "First name", "first name", "first Name"]
LAST_NAME_FORMATS = ["Last Name", "Last name", "last name", 'last Name']
EMAIL_FORMATS = ["Email", "EMAIL", "email"]
BASIC_PHONE_FORMATS = ["Phone", "phone", "PHONE"]
EXTRA_PHONE_FORMATS = (("phone device type", "device type", "device"), 
                       ("country phone code", "country code", "country"), 
                       ("phone number", "number", "phone"))
ZIPCODE_FORMATS = ["Postal Code", "Zip Code", "zipcode"]
COUNTRY_FORMATS = ["country"]

BANNED_COMPANY_LIST = ("google")

TAG_NAMES = set()

class FAILURE_LEVELS(str, Enum):
    fail = "fail"
    boolean = "boolean"
    none = "none"
    silent = "silent"

class TAGS(str, Enum):
    _title = "@title"
    _aria_label = "@aria-label"
    _type = "@type"
    _class = "@class"
    _value = "@value"
    _id = "@id"
    _d = "@d"
    _all_text = "."

def setup_logger():
    global LOG
    LOG = logging.getLogger(__name__)
    if not LOG.hasHandlers():
        logging.basicConfig(filename="output.log", encoding="utf-8", level=logging.INFO)
        console_handler = logging.StreamHandler(sys.stdout)
        LOG.addHandler(console_handler)
        LOG.info("Logging enabled, logging level is 'info'")
    

class TestQuickApply():
    """_summary_
    """
    def __init__(self, driver=None):
        """_summary_

        Args:
            driver (_type_, optional): _description_. Defaults to None.
        """
        self.set_driver(driver)
        self.vars = {}
        self.wait = WebDriverWait(self.driver, 10) # explicit wait, when called will wait for the condition and timeout after 10 secs

    def set_driver(self, driver=None):
        """ Sets or creates the Selenium webdriver object.

        Depending on the argument "driver" the method either creates a new webdriver for the Firefox browser, sets the driver to the "driver" argument,
        or reloads a driver from a previous session. This last option is useful when reloading the module in the python interpreter to maintain the same
        driver and not have to reopen the web pages again.

        Args:
            driver (_type_, optional): Either "reload" to reload the previous sessions driver if still open, a webdriver object, or None to create a 
            new webdriver. Defaults to None.
        """
        global GLOBAL_DRIVER # the global variable is not destroyed when reloading a module using importlib.reload()
        if driver == "reload":
            self.driver = GLOBAL_DRIVER
        elif driver is None:
            self.driver = webdriver.Firefox()
        else:
            self.driver = driver 
        GLOBAL_DRIVER = self.driver
        if self.driver is not None:
            LOG.info("Driver added")
  
    def teardown_method(self, method=None):
        """_summary_

        Args:
            method (_type_, optional): _description_. Defaults to None.
        """
        self.driver.quit()
    
    def switch_tab(self, tab_num):
        """_summary_

        Args:
            tab_num (_type_): _description_
        """
        num_tabs = len(self.driver.window_handles)
        if tab_num > (num_tabs - 1):
            LOG.info(f"Total number of open tabs tracked by the webdriver is currently {num_tabs}\nPlease try again between 0 - {num_tabs-1}")
            return
        else:
            self.driver.switch_to.window(self.driver.window_handles[tab_num])
  
    def scroll_to_element(self, element):
        """_summary_

        Args:
            element (_type_): _description_
        """
        self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
        time.sleep(1)

    def is_element_in_viewport(driver, element):
        """_summary_

        Args:
            driver (_type_): _description_
            element (_type_): _description_

        Returns:
            _type_: _description_
        """
        return driver.execute_script(
            "var rect = arguments[0].getBoundingClientRect();"
            "return ("
            "rect.top >= 0 && "
            "rect.left >= 0 && "
            "rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && "
            "rect.right <= (window.innerWidth || document.documentElement.clientWidth)"
            ");",
            element
        )
    
    def find_element(self, start, type, tag: TAGS, contains: list, failure_level: FAILURE_LEVELS, case_insensitive=True):
        """_summary_

        Args:
            start (_type_): _description_
            type (_type_): _description_
            tag (TAGS): _description_
            contains (list): _description_
            failure_level (FAILURE_LEVELS): _description_
            case_insensitive (bool, optional): _description_. Defaults to True.

        Returns:
            _type_: _description_
        """
        elements_found = []
        idx = 0
        while (len(elements_found) == 0 and idx < len(contains)):
            if case_insensitive:
                elements_found = start.find_elements(By.XPATH, 
                            f".//{type}[contains(translate({tag}, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '{contains[idx].lower()}')]")
            else:
                elements_found = start.find_elements(By.XPATH, f".//{type}[contains({tag}, {contains[idx].lower()})]")
            idx += 1

        if failure_level.lower() == "fail":
            assert len(elements_found) > 0
        elif failure_level.lower() == "boolean":
            if len(elements_found) == 0:
                return False
        elif failure_level.lower() == "none":
            if len(elements_found) == 0:
                return None
        elif failure_level.lower() == "silent":
            if len(elements_found) == 0:
                return
        return elements_found[0]
    
    def open_tabs(self, url_list):
        """_summary_

        Args:
            url_list (_type_): _description_
        """
        for url in url_list:
            prev_num = len(self.driver.window_handles)
            self.driver.switch_to.new_window('tab')
            self.wait.until(expected_conditions.number_of_windows_to_be(prev_num+1))
            self.driver.get(url)
            time.sleep(.1)
        self.driver.switch_to.window(self.driver.window_handles[0])
        prev_num = len(self.driver.window_handles)
        self.wait.until(lambda d: self.driver.current_window_handle == self.driver.window_handles[0])
        self.driver.close()
        self.wait.until(lambda d: len(self.driver.window_handles) == prev_num - 1)
        self.driver.switch_to.window(self.driver.window_handles[0])
        self.driver.maximize_window()
        LOG.info(f"Opened {len(self.driver.window_handles)} tabs")
    
    def fill_first_name(self):
        """_summary_
        """
        first_name_label = self.find_element(self.driver, "label", TAGS._all_text.value, FIRST_NAME_FORMATS, FAILURE_LEVELS.boolean.value)
        if first_name_label != False:
            if len(first_name_label.find_elements(By.XPATH, ".//input")) > 0:
                input_element = first_name_label.find_elements(By.XPATH, ".//input")
            elif len(first_name_label.find_elements(By.XPATH, "./..//input")) > 0:
                input_element = first_name_label.find_elements(By.XPATH, "./..//input")
            if input_element[0].is_displayed() == False:
                self.scroll_to_element(input_element[0])
            input_element[0].send_keys("Samuel")
            LOG.info("Keys sent to first name")
        else:
            LOG.info("No first name label found")

    def fill_last_name(self):
        """_summary_
        """
        last_name_label = self.find_element(self.driver, "label", TAGS._all_text.value, LAST_NAME_FORMATS, FAILURE_LEVELS.boolean.value)
        if last_name_label != False:
            if len(last_name_label.find_elements(By.XPATH, ".//input")) > 0:
                input_element = last_name_label.find_elements(By.XPATH, ".//input")
            elif len(last_name_label.find_elements(By.XPATH, "./..//input")) > 0:
                input_element = last_name_label.find_elements(By.XPATH, "./..//input")
            input_element[0].send_keys("Warrick")
            LOG.info("Keys sent to last name")
        else:
            LOG.info("No last name label found")
    
    def fill_email(self):
        """_summary_
        """
        email_label = self.find_element(self.driver, "label", TAGS._all_text.value, EMAIL_FORMATS, FAILURE_LEVELS.boolean.value)
        if email_label != False:
            if len(email_label.find_elements(By.XPATH, ".//input")) > 0:
                input_element = email_label.find_elements(By.XPATH, ".//input")
            elif len(email_label.find_elements(By.XPATH, "./..//input")) > 0:
                input_element = email_label.find_elements(By.XPATH, "./..//input")
            input_element[0].send_keys("swarrick6@gmail.com")
            LOG.info("Keys sent to email")
        else:
            LOG.info("No input email label found")
    
    def fill_phone(self):
        """_summary_
        """
        phone_label = self.find_element(self.driver, "label", TAGS._all_text.value, BASIC_PHONE_FORMATS, FAILURE_LEVELS.boolean.value)
        if phone_label != False:
            input_element = self.find_input_element(phone_label)
            if input_element == 1:
                input_element[0].send_keys("5794215985")
            elif len(input_element) > 1: # TODO: check if they want mobile, country code, etc
                LOG.debug("Need more phone info")
                #for extra_label in input_element:
                    #for label_set in EXTRA_PHONE_FORMATS:
                        #if extra_label.lower() in label_set:
                            #input_element = self.find_input_element(extra_label)
                            #if EXTRA_PHONE_FORMATS[0] == label_set: # Device type
                                #input_element.send_keys("Mobile")
            else:
                LOG.info("Phone label found but no phone input box found")
        else:
            LOG.info("No input phone label found")

    def fill_zipcode(self):
        """_summary_
        """
        zip_label = self.find_element(self.driver, "label", TAGS._all_text.value, ZIPCODE_FORMATS, FAILURE_LEVELS.boolean.value)
        if zip_label != False:
            if self.find_input_element(zip_label) != None:
                # TODO: may need try and catch if the input is not ready for canada postal codes (setting country first should fix)
                self.find_input_element(zip_label)[0].send_keys("H2L 4A8")
            else:
                LOG.info("Zipcode label found but no zipcode input box found")
        else:
            LOG.info("No input zipcode/postal code label found")

    def fill_country(self):
        """_summary_
        """
        country_label = self.find_element(self.driver, "label", TAGS._all_text.value, COUNTRY_FORMATS, FAILURE_LEVELS.boolean.value)
        if country_label != False:
            if self.find_element(country_label) != None:
                input = self.find_element("input")
                clr_btn = self.find_element("button")
                if clr_btn.is_displayed() == False:
                    input.click() #select input element to make clear button clickable
                self.wait.until(lambda d: clr_btn.is_displayed())
                clr_btn.click()
                input.send_keys("Canada")
                input.send_keys(Keys.ENTER)
            else:
                LOG.info("Country label found but no country input box found")
        else:
            LOG.info("No country label found")

    def fill_address(self):
        pass

    def fill_location(self):
        pass

    def fill_job_origin(self):
        pass
    
    def fill_work_auth(self):
      pass

    def fill_education(self):
      pass

    def fill_experience(self):
      pass

    def fill_skills(self):
      pass

    def fill_identity_data(self):
      pass

    def find_tag_names(self):
        """_summary_
        """
        for tab in self.driver.window_handles:
            self.driver.switch_to.window(tab)
            time.sleep(.1)

            elements = self.driver.find_elements(By.XPATH, "//*")
            for ele in elements:
                TAG_NAMES.add(ele.tag_name)
    
    def write_tag_names(self):
        """_summary_
        """
        with open("tag_names.txt", "a") as file:
            i = 0
            for tag in TAG_NAMES:
                if i % 10 == 0:
                    file.write("\n") #newline
                file.write(f"{tag} | ")
                i += 1     
  
    def test_quickapply(self):
        """_summary_
        """
        url_list = ["https://boards.greenhouse.io/tenstorrent/jobs/4602366007?lever-source=LinkedIn&lever-origin=applied&source=LinkedIn", 
                    "https://www.varsitytutors.com/en-ca/tutor-application?code_id=s200904-9377-682-2024214&location=Toronto&rx_campaign=Linkedin1&rx_ch=connector&rx_group=131611&rx_job=s200904-9377-682-2024214rxv_4_2&rx_medium=post&rx_r=none&rx_source=Linkedin&rx_ts=20240830T121204Z&rx_vp=slots&subject=python&variant=Canada&vtsubject=python&rx_viewer=02508b1dd1c511efb4dcebc0ac1bbcf49b64bd520d4f48ae89d5c43411cc2e23", 
                    "https://wd5.myworkdaysite.com/en-US/recruiting/microchiphr/External/job/Canada---Burnaby/Engineer-II---Validation_R2630-24?utm_campaign=LinkedIn", 
                    "https://www.google.com/about/careers/applications/jobs/results/91745972261921478-silicon-validation-engineer/?src=Online/LinkedIn/linkedin_us&utm_source=linkedin&utm_medium=jobposting&utm_campaign=contract"]
        self.open_tabs(url_list)
        #check for login info
        #self.sign_in()
        time.sleep(20) # verify actions by user

        # will probebly need a login, may need to do manually, do this last
        # may need to click an "apply" button to jump to the application page
            # can be one or more pages of information to fill out
                # each page should check a list of things such as name, location, address, identity questions, job experience, etc
                # to move to the next page can be "Next", "Continue", "Save and Continue"
            # to submit application can be "Submit", "Submit Application", etc but will want to do that manually
    
        # figure out how I want to check what elements exist on the page to be able to call the correct fill method
        #fill_methods = {"first name": self.fill_first_name, "last name": self.fill_last_name}
        #fill_element_formats = {"first name": FIRST_NAME_FORMATS, "last name": LAST_NAME_FORMATS}
        #for fill_element in fill_element_formats.keys():
            #if self.find_label(fill_element, FAILURE_LEVELS.boolean) != False:
                #fill_methods[fill_element]()
        
        # once continuing to the next page, switch context to the next tab to start working on filling out that tab
        # need to check if element needs to be scrolled into view
        # TODO: When filling input boxes, check for more than one box as this will present possible errors
        # TODO: Do element need to be scrolled into view? From quick initial testing does not seem like it is necessary?
        
        time.sleep(10)
        self.teardown_method()
    